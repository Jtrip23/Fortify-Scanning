FMK-20250401T173337Z
Be aware this one is old. The readme has an example tag, but this builds weekly.
 
The error on dotnet build:
 
If you have a .proj and a .sln, you can't just dotnet build - you have to say WHAT to build
dotnet build ./foo.sln
 
(That's not the container, that's standard dotnet)
 
   variables:
  ### Base variables that depend on order of declaration.
  # VERSION_PREFIX is the container version. The chart version is controlled in
  # deploy/helm-chart/Chart.yaml. If you increment the VERSION_PREFIX you need
  # to update the appVersion in Chart.yaml.
  VERSION_PREFIX: "0.3.5"
  BUILD_NAME: "$VERSION_PREFIX-alpha+sha.$CI_COMMIT_SHORT_SHA ($CI_COMMIT_TITLE)"
  FMK_PULL_REGISTRY: fmk.nexus.onefiserv.net
  FMK_PUSH_REGISTRY: fmk.nexus-ci.onefiserv.net
  ### Docker variables to enable Docker-in-Docker to work right.
  DOCKER_CERT_PATH: "/certs/client"
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: tcp://docker:2376/
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_TLS_VERIFY: 0
  ### Log formatting
  TXT_BOLD: "\e[1m"
  TXT_CLEAR: "\e[0m"
  TXT_GREEN: "\e[32m"
  TXT_RED: "\e[31m"
  TXT_YELLOW: "\e[33m"
  ### The rest of the variables in alpha order.
  APPSEC_IMAGE: $FMK_PULL_REGISTRY/fmk/dev-tools/fmk-ubi8-appsec
  BUILD_IMAGE: $FMK_PULL_REGISTRY/fmk/dotnet/dotnet-8.0-build
  DIND_IMAGE: $FMK_PULL_REGISTRY/fmk/ext-tools/fmk-dind
  DOCKER_BUILDKIT: "1"
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "true"
  # Turn off signature verification - it's blocked by the Fiserv firewall and causes build timeouts.
  DOTNET_NUGET_SIGNATURE_VERIFICATION: "false"
  OUTPUT_IMAGE: $FMK_PUSH_REGISTRY/fmk/tools/image-pull-secret-replicator
  PUBLISH_CHART: 0
  PUBLISH_CONTAINER: 0
  RUNTIME_IMAGE: $FMK_PULL_REGISTRY/fmk/dotnet/dotnet-8.0-aspnet
  SCAN_VERSION: image-pull-secret-replicator
  APM_ID: APM0008206

# When we've upgraded to GitLab 16.x, move the semantic version and build name
# update to script so we can incorporate the current date and/or pipeline ID -
# things not available to `workflow`.
#
# https://docs.gitlab.com/ee/api/pipelines.html#update-pipeline-metadata
# - GITLAB_BUILD_METADATA_URL="$CI_API_V4_URL/projects/$CI_PROJECT_ID/pipelines/$CI_PIPELINE_ID/metadata"
# - curl --request PUT --header "JOB-TOKEN: $CI_JOB_TOKEN" --data "name=$BUILD_NAME" --fail "$GITLAB_BUILD_METADATA_URL"
workflow:
  name: $BUILD_NAME
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        BUILD_NAME: "$VERSION_PREFIX+sha.$CI_COMMIT_SHORT_SHA ($CI_COMMIT_TITLE)"
        PUBLISH_CONTAINER: 1
        # Only publish chart on main - there are no 'beta' Helm chart versions.
        PUBLISH_CHART: 1
    - if: '$CI_COMMIT_BRANCH == "develop"'
      variables:
        BUILD_NAME: "$VERSION_PREFIX-beta+sha.$CI_COMMIT_SHORT_SHA ($CI_COMMIT_TITLE)"
        PUBLISH_CONTAINER: 1
    - if: "$CI_COMMIT_BRANCH  =~ /^release/"
      variables:
        SEMANTIC_VERSION: "$VERSION_PREFIX-rc+sha.$CI_COMMIT_SHORT_SHA"
        BUILD_NAME: "$VERSION_PREFIX-rc+sha.$CI_COMMIT_SHORT_SHA ($CI_COMMIT_TITLE)"
        PUBLISH_CONTAINER: 1
    - if: "$CI_COMMIT_BRANCH  =~ /^feature/"

stages:
  - init
  - build
  - test
  - package

set-versions:
  stage: init
  image: $DOCKER_DIND_BASE
  script:
    - bash ./build/pipeline/get_latest_tags.sh
    - ISO_DATE=$(date -u +%Y%m%dT%H%M%SZ)
    - >
      case "$CI_COMMIT_BRANCH" in
        "main")
          IMAGE_TAG="$VERSION_PREFIX"
          SEMANTIC_VERSION="$VERSION_PREFIX+sha.$CI_COMMIT_SHORT_SHA"
          ;;
        "develop")
          IMAGE_TAG="$VERSION_PREFIX-beta$ISO_DATE"
          SEMANTIC_VERSION="$VERSION_PREFIX-beta$ISO_DATE+sha.$CI_COMMIT_SHORT_SHA"
          ;;
        "release/*")
          IMAGE_TAG="$VERSION_PREFIX-rc$ISO_DATE"
          SEMANTIC_VERSION="$VERSION_PREFIX-rc$ISO_DATE+sha.$CI_COMMIT_SHORT_SHA"
          ;;
        *)
          IMAGE_TAG="$VERSION_PREFIX-alpha$ISO_DATE"
          SEMANTIC_VERSION="$VERSION_PREFIX-alpha$ISO_DATE+sha.$CI_COMMIT_SHORT_SHA"
          ;;
      esac
    - echo "IMAGE_TAG=$IMAGE_TAG" >> build.env
    - echo "SEMANTIC_VERSION=$SEMANTIC_VERSION" >> build.env
  artifacts:
    reports:
      dotenv: build.env

ensure-required-variables:
  stage: init
  image: $DOCKER_DIND_BASE
  script:
    - >
      if [ -z "$FORTIFY_TOKEN" ]; then
        echo "Set the FORTIFY_TOKEN variable in the GitLab CI/CD settings to your Fortify SAST access token."
        exit 1
      fi
    - >
      if [ -z "$SONATYPE_USERCODE" ]; then
        echo "Set the SONATYPE_USERCODE variable in the GitLab CI/CD settings to your Sonatype IQ username/usercode."
        exit 1
      fi
    - >
      if [ -z "$SONATYPE_PASSCODE" ]; then
        echo "Set the SONATYPE_PASSCODE variable in the GitLab CI/CD settings to your Sonatype IQ passcode."
        exit 1
      fi
    - >
      if [ -z "$FORTIFY_EMAIL" ]; then
        echo "Set the FORTIFY_EMAIL variable in the GitLab CI/CD settings to the email that should receive Fortify SAST scan update notifications."
        exit 1
      fi

build-controller:
  stage: build
  image: "$BUILD_IMAGE:$LATEST_BUILD"
  script:
    # Build and test. Post-processing handles colorizing the build log output
    # and correcting the exit code for warnings.
    - dotnet msbuild ./default.proj -p:Configuration=Release -p:Version=$SEMANTIC_VERSION || true
    - |
        log_dir=./artifacts/log
        for entry in "$log_dir"/build-*.json
        do
          pwsh -NoProfile ./build/pipeline/ConvertTo-BuildLog.ps1 -ReportPath $entry
        done
    # Validate coverage.
    - pwsh -NoProfile ./build/pipeline/Confirm-Coverage.ps1 -ReportPath ./artifacts/log/coverage.cobertura.xml
  allow_failure:
    exit_codes:
      - 127
  artifacts:
    when: always
    paths:
      - artifacts/log/build-*.json
      - artifacts/log/*test-result.xml
      - artifacts/log/coverage.cobertura.xml
      - artifacts/package/
    reports:
      junit:
        - artifacts/log/*test-result.xml
      coverage_report:
        coverage_format: cobertura
        path: artifacts/log/coverage.cobertura.xml

build-chart:
  stage: build
  image: $DOCKER_DIND_BASE
  script:
    - mkdir -p ./artifacts/charts
    - helm lint ./deploy/helm/image-pull-secret-replicator --strict --with-subcharts
    - helm package ./deploy/helm/image-pull-secret-replicator -d ./artifacts/charts
  artifacts:
    when: always
    paths:
      - artifacts/charts/

fortify-scan:
  stage: test
  image: "$BUILD_IMAGE:$LATEST_BUILD"
  script:
    - mkdir -p artifacts/fortify
    - pwsh -NoProfile /etc/fortify/bin/Start-FortifyScan.ps1 -BuildId "$CI_PIPELINE_ID" -Source . -Application $APM_ID -Version "$SCAN_VERSION" -Token "$FORTIFY_TOKEN" -Email "$FORTIFY_EMAIL" -OutputFolder artifacts/fortify -Publish
    - pwsh -NoProfile ./build/pipeline/Write-FortifyIssues.ps1 -FortifyReportsDirectory ./artifacts/fortify -FortifyJson ./.fortify.json
  artifacts:
    when: always
    paths:
      - artifacts/fortify/

sonatype-scan:
  stage: test
  image: "$DIND_IMAGE:$LATEST_DIND"
  services:
    - name: "$DIND_IMAGE:$LATEST_DIND"
      alias: docker
  tags:
    - docker
  before_script:
    - until docker info; do sleep 1; done
  script:
    - docker run -i --rm -v $(pwd):/code $APPSEC_IMAGE:$LATEST_APPSEC /app/lifecycle/sonatype.sh "${APM_ID}_${SCAN_VERSION}" $SONATYPE_USERCODE $SONATYPE_PASSCODE /code
  inherit:
    default: true
    variables: true

package-and-push:
  stage: package
  image: "$DIND_IMAGE:$LATEST_DIND"
  services:
    - name: "$DIND_IMAGE:$LATEST_DIND"
      alias: docker
  tags:
    - docker
  before_script:
    - until docker info; do sleep 1; done
  script:
    - echo "$FMK_PASSWORD" | docker login -u $FMK_USER $FMK_PULL_REGISTRY --password-stdin
    - echo "$FMK_PASSWORD" | docker login -u $FMK_USER $FMK_PUSH_REGISTRY --password-stdin
    - echo "$FMK_PASSWORD" | helm registry login $FMK_PUSH_REGISTRY -u $FMK_USER --password-stdin
    - docker build -t $OUTPUT_IMAGE:$IMAGE_TAG --build-arg BASE_TAG=$LATEST_RUNTIME --build-arg GIT_COMMIT=$CI_COMMIT_SHA --build-arg SEMANTIC_VERSION=$SEMANTIC_VERSION --build-arg BUILD_DATE=$(date -u +%Y%m%dT%H%M%SZ) artifacts/package
    - bash ./build/pipeline/wiz_scan.sh "$WIZ_CLIENT" "$WIZ_SECRET" "$OUTPUT_IMAGE:$IMAGE_TAG"
    - bash ./build/pipeline/publish.sh $PUBLISH_CONTAINER "$OUTPUT_IMAGE:$IMAGE_TAG" $PUBLISH_CHART
  inherit:
    default: true
    variables: true
  artifacts:
    when: always
    paths:
      - artifacts/wiz/

        The build-controller stage is where the dotnet msbuild runs
